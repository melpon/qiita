例えばあるプロセスからあるプロセスへ、Aというメッセージを送った後にBというメッセージを送るコードを書いた場合、受信側はA, Bという順序で受信することが保証されているかどうか、というのが気になったので調べました。

## 結論から

順序は保証されるようです。

- [10.8  Is the order of message reception guaranteed?](http://erlang.org/faq/academic.html#idp33232112)

受信側にBというメッセージが届いてるなら、Aというメッセージはそれより前に到着してることが保証されている、とのこと。

少なくとも同じノード内だけは順序が保証されて欲しいと思っていたのですが、これを見る限りノードを超えても順序は保証されてそうです。

## 到達保証

もう一つ疑問に思ったのは、メッセージが届く保証がどのレベルであるのかということです。

メッセージは、直感的には、必ず、1回だけ届くことを期待します。
つまり、あるメッセージが届かないなんてことは考えないし、同じメッセージが2回届くことなんて考えません。
しかし、ネットワークを超えたメッセージのやりとりでは、ネットワークが一瞬切断されて復活した、みたいな場合に以下のようなことがありがちです。

- 受信側に、メッセージAが届かず、その次のメッセージBだけが届く
- 受信側にメッセージAは届いたのだけど、無事受信できたというACKが送信側に届かず、送信側がメッセージAが届かなかったと勘違いして再度メッセージAを送信する。そのためメッセージAが2回届く

ノードを超えてメッセージをやり取りした際に、受信側がこれらのケースを考慮する必要があるかどうかが気になるところです。

これに関しても同じような場所に答えが載っていました。

- [10.9  If I send a message, is it guaranteed to reach the receiver?](http://erlang.org/faq/academic.html#idp33057520)

これを読む限り、条件付きだけれども、必ず1回届くという保証なっているようです。
2回以上届くことはない、と明確に言ってくれてる訳ではないですが、2回以上届く可能性があるなら、「TCPと同程度の保証がある」みたいな書き方はしないはずなので、多分大丈夫でしょう。

条件付き、というのは、ネットワークやプロセスがクラッシュしたりするとメッセージが届かなくなるし、それらの情報は失われるということです。
ただし、必ず1回届く、という保証から考えると、ある時点から全てのメッセージが届かなくなるということはあっても、途中のメッセージが抜けてしまった状態で受信したり、複数回同じメッセージを受信したりなどの現象は起きないはずです。

また、`link/1`や`monitor/2`などで監視してれば、そのプロセスが何かおかしくなったということが分かるし、確実に処理されたことを保証したいなら `gen_server:call/3` やそれに相当する処理を書けばいいので、それらを使えばうまいことハンドリングできそうです。

## まとめ

Erlangのメッセージは、同じプロセスから送ったメッセージの順序が保証されていて、それらのメッセージは何らかの問題が起きるまで必ず1回だけ届くことが保証されています。

要するに **あれこれ考えず普通にメッセージ送受信するコードを書けば普通に動く** ので、難しいことは考えず普通に書きましょう。
