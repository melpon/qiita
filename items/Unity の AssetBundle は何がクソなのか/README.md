これは AssetBundle をひたすらクソと言い続けるエントリーだ。

# 追記

Unity5でかなり良くなったらしい

- http://www.slideshare.net/MakotoItoh/kansai-cedec

# 前提

iOS と Android 向けのモバイルゲームによくある、

- 本体の容量を 100MB、50MB 以内に収めつつ、
- 初回起動時に数百 MB ダウンロードさせ、
- リソースの更新を追加ダウンロードによって行なう

という機能の実現に AssetBundle を利用するものとする。

# AssetBundle の概要

Unity で、特定の機能を使ってアセットをシリアライズしたファイルを AssetBundle と呼ぶ。
通常、Unity のアセットは、プロジェクトのビルド時に全て含まれるのだけれども、AssetBundle はそれとは別で独立して作ることができる。
そのため、AssetBundle をネットワーク上に置いておき、アプリケーションの中からダウンロードして使うのが主な利用法となる。
以下のサイトを見れば大体分かる。

- [アセットバンドル（Unity Proのみ）](http://docs-jp.unity3d.com/Documentation/Manual/AssetBundlesIntro.html)
- [Unite Japan 2013 公開動画 - [Unite Japan 2013]シーン／メモリ／アセットバンドル](http://vimeopro.com/unity3djp/unite-japan-2013-for-the-public/video/64375290)

これだけ見ると便利そうなのだが、実際に使ってみるとクソだらけだった。
以下、クソな点を詳細に書いていく。

ただし、このエントリーは「何がクソなのか」を解説するだけだ。
どのように解決したか、というのはまた別のエントリーとして上げる予定（あくまで予定）だ。

# 同じ AssetBundle をロードするとエラーになる

- [ロードされたアセットバンドルのトラッキング方法](http://docs-jp.unity3d.com/Documentation/Manual/keepingtrackofloadedassetbundles.html)

このドキュメントにあるように、同じ AssetBundle を複数個同時にロードすることはできない。
`AssetBundle.Unload` すれば、再度ロードできるようになる。

これだけ見れば「複数個同時にロードするとメモリの無駄だから、ロード出来ないのは正しい」と思うかもしれない。
しかしエラーにされると困るのだ。
エラーは単にコンソールにエラーログが出た上で `null` が返されるだけなので、このエラーの場合だけはリトライする、みたいな処理を書くことは想定していないはずだ。
そのため、このエラーは単にロードに失敗してしまったという扱いにせざるを得ず、そしてロードの失敗というのは、わりとどうしようもないエラーであるため、ハンドリングしようが無い。出たらオシマイである。

CPU やネットワークを効率的に利用するため、複数のコルーチンを使って同時にリソースをロードするというのは、よくある処理である。
あるいは次のシーンのために先行でロードを行なうのも、よくある処理である。
そのような場合に、同じ AssetBundle を読もうとしてしまうことは、よくある出来事だ。

なのに手の打ちようのないエラーを返されると、非常に困る。
せめて、既にロード済みかを調べる関数を用意するか、メモリが無駄になってもいいから重複してロードするか、あるいは何も言わずに、既にロード済みの AssetBundle と同じ参照を返す（でもって `Unload` をうまいこと何とかする）か、そういうことをするべきだ。

かなり面倒なコードを書かないと AssetBundle を安心してロードすることすらできない AssetBundle はクソである。

# 無圧縮がクソでかい

AssetBundle を生成する際に、圧縮で作るか無圧縮で作るかが選択できる。
無圧縮で作った場合、メモリ領域を取らず、読み込み速度が早い。その代わりディスクを圧迫する。
圧縮で作った場合、メモリ領域を取るし、読み込み速度が遅い。しかしディスク容量は少なくなる。

（正直、圧縮で作った場合にわざわざメモリ領域を取る理由が分からない。AssetBundle に含まれている全てのアセットを走査するという前提なら、アセットを展開しながらロードすることもできたはずだ。）

最初に作った時は `WWW.LoadFromCacheOrDownload` を使った。
ダウンロードと無圧縮でのロードを同時にやってくれるため、楽ができると思ったからだ。
しかししばらく使っていて、無圧縮というものを勘違いしていたことに気がついた。

無圧縮というのは、単にそのアセット（とそこから依存しているアセット）の合計ぐらいになるものだと思っていた。
しかし実際は、画像がピクセルデータになって保存される。
つまり 2048x2048 の RGBA 画像を AssetBundle に含めるだけで、サイズが **16MB** 増えることになるのだ。
確かに `glTexImage2D` をする際には無圧縮の方が都合がいいのだろうけれども、いくら何でも極端過ぎる。
Windows のゲームをインストールしたら、**ビットマップファイル**が大量に作られているようなものである。
ある程度展開の早い圧縮方式だと、ファイルから読んでくる速度より展開速度の方が勝ってしまうのでは無いかという気もする。
（iOS、Android ならシーク時間が無いだけマシなのだろうけど）

今回やっていたプロジェクトでは、圧縮時に 500MB 程度だったデータを `WWW.LoadFromCacheOrDownload` すると **3GB** になった。
そんなサイズをユーザの端末に保存させるのは有り得ない。

効率が良いとか言って無圧縮にし、使い物にならないゴミになった AssetBundle はクソである。

（あとついでに言うと、圧縮した AssetBundle を作った場合に、キャッシュに格納されるサイズ（無圧縮状態でのサイズ）が分からない点もクソだ。）

# 大きいサイズの AssetBundle を使えない

Unity は、Unity が管理するメモリと、Mono のメモリに分かれている。
Mono のメモリは、例えば `new byte[100]` などした場合に使われるメモリである。
このメモリの最大サイズは、メモリが足りなくなる度に増えていく。
そして、**一度最大サイズが増えたら二度と減らない** のだ。

例えば最初は Mono メモリの最大サイズが 5MB だったとしても、テンポラリ領域として 1MB の領域を 10 個確保したら、いつの間にか、再確保なのかページを増やしているのかは知らないが、Mono メモリの最大サイズが増加しているのだ。
そしてそのテンポラリ領域を GC が解放しても、Mono メモリの最大サイズは減らない。
それ以降、5MB 以内の Mono メモリしか消費しないとしても、Mono に確保された最大サイズは変わらないため、メモリの節約にはならないのだ。
つまり、Mono の消費メモリを少なくしたいなら、**瞬間的にすら大量の Mono メモリを扱ってはならない**。

そして、AssetBundle は、前述の無圧縮の問題があるため、`WWW.LoadFromCacheOrDownload` を使うことはできない。
そのような場合、`WWW` を使って AssetBundle をダウンロードすることになるのだが、`WWW` でダウンロードした結果は `WWW.bytes` に入っていて、これは **Mono のメモリを使っている** 。
あるいは圧縮した AssetBundle のファイルを読み込んで `AssetBundle.CreateFromMemory(byte[])` を使う場合にも、そのバッファは **Mono のメモリを使う** ことになる。

つまり、大きいサイズの AssetBundle を使うと、ダウンロードしたりロードする際に、瞬間的に大量の Mono メモリを取ることになる。
そのせいで Mono メモリの最大サイズが増えてしまって、アプリケーション全体のメモリ領域を圧迫することになるのだ。

圧縮した AssetBundle をストリーミングで読み込むなりの機能が存在しない AssetBundle、クソである。

# 重複アセットを消すのが難しい

ある AssetBundle に含まれるプレハブが参照しているアセットと、別の AssetBundle に含まれるプレハブが参照しているアセットが同じだった場合、それらのアセットは別のアセットとしてそれぞれの AssetBundle に含まれてしまう。
これはファイルサイズ的にもメモリ的にも無駄である。

これを何とかするには、以下の方法が考えられる。

- 同じアセットを参照しているプレハブを１つの AssetBundle にする
- 同じアセットを参照しているプレハブは１つのプレハブにマージしてしまう
- `AssetBundle.PushDependencies` を使う

しかし、複数のプレハブを１つの AssetBundle にしたり１つのプレハブにマージするという方法は、あまりやり過ぎると、前述した「大きいサイズの AssetBundle が使えない」という問題に引っかかる。
また、大きいサイズの AssetBundle は、一部のリソースに更新を掛けるだけで大量のデータをユーザにダウンロードさせることになるため、その点でも問題がある。
あと、全てのプレハブについてこれを手動でやるのは、かなりキツい。

`AssetBundle.PushDependencies` を使うのは、[サンプル](http://docs.unity3d.com/ScriptReference/BuildPipeline.PushAssetDependencies.html)を見ただけで、使うのがかなり難しいというのが分かる。
これをまともに使うには、どのプレハブがどのアセットを参照するのかを理解した上で AssetBundle を生成し、ロードする際にも正しい順番で AssetBundle をロードしなければならない。
数十個の AssetBundle なら何とかなるかもしれないが、数千個の AssetBundle でそれをやるのは、かなり難しいだろう。

これは根本的に AssetBundle の仕組みが悪い。
普通の Resource 以下にあるデータなら、こんなことは考えずにプレハブを作ることができていたのに、AssetBundle 化する時に、いきなり複雑な依存関係を意識しなければならなくなっているのだ。

「このフォルダ以下を AssetBundle 化する」とかやると、適切なサイズに分割されたファイルが作られ、プレハブをロードしようとしたら、分割されたファイルから必要なファイルを集めてプレハブを構築してくれる、しかも更新があった際のデータも簡単に作れる、みたいな機能があればベストだと思う。
それが無理でも、もっと依存関係を簡単に調べてリアルタイムで警告を出してくれるツールみたいなのが欲しいところである。
`AssetDatabase.GetDependencies` だけで逆参照を調べるのはかなり大変なのだ。

重複したアセットを消したいだけなのにここまで苦労させる AssetBundle はクソだ。

# スクリプトを含めるのが難しい

スクリプトを関連付けているプレハブを AssetBundle 化するのは、可能である。
しかし、この AssetBundle 内には、スクリプト本体が含まれている訳ではなく、スクリプトへの参照や CRC などを保持しているだけである。
そしてこの AssetBundle のロード時に、アプリケーション本体にあるスクリプトを関連付ける。

これはつまり、スクリプトを AssetBundle で配信できないことを意味する。
スクリプト本体が AssetBundle に含まれないからだ。
ただ、これに関しては、iOS などの JIT コンパイルが不可能な環境のことを考慮すると仕方が無いだろう。

それよりも致命的な問題がある。
**アプリケーション本体を更新すると、AssetBundle のロードに失敗する可能性がある** ということだ。
ダウンロードした AssetBundle に全く手を入れてないにも関わらず、である。

先ほど「AssetBundle のロード時に、アプリケーション本体にあるスクリプトを関連付ける」と書いたが、実際には、このスクリプトを関連付ける際に、AssetBundle 生成時に参照しているスクリプトの CRC と、アプリケーション本体に入っているスクリプトの CRC が一致しているかどうかを見ている。
そのため、アプリケーションの更新に AssetBundle 化したプレハブが参照しているスクリプトが含まれていた場合、それを参照している AssetBundle は**全てロードに失敗する**。新しく生成し直した AssetBundle をダウンロードしてくるしか無い。

スクリプト１つ更新しただけで、プレハブに関連付けられていたデータを全て落とし直すことになる。ユーザにとってはいい迷惑である。クソだ。

# 互換性が無い

AssetBundle が Unity のどのバージョンで互換性があるか、公式でははっきりとは書かれていない。
Unity は好きなタイミングで互換性を壊すことができる。
そして互換性が無い場合、**全ての AssetBundle のロードに失敗**する。
つまりアプリケーションのユーザは**全ての AssetBundle をダウンロードし直さなければならない**。
開発者は、いつ互換性が無くなるか分からないという爆弾を抱えながら AssetBundle を作ることになる。
そしてユーザは、開発者の都合で数百MBのファイルをダウンロードし直さなければならなくなるのだ。

最近、チーム全体で Unity を 4.5.1 から 4.5.5p5 に上げたが、AssetBundle の互換性は無かった。
ユーザは、**数百MBのファイルをダウンロードし直し**である。

なお、4.5.1 は2014年7月から使い始めた。
チーム全体で 4.5.5p に上げたのは2014年11月のことである。
7月から11月まで、AssetBundle は**わずか4ヶ月の命**だった。

Unity は１〜２週間に１回のペースでマイクロバージョンアップ、あるいはパッチリリースを行っている。
今現在、既に 4.6.1p2 が出ているが、マイクロバージョンが上がっただけで無くなっていた互換性だ、マイナーバージョンが上がったのなら恐らく互換性は無いだろう。

バージョンがすぐに上がる割に互換性の無い AssetBundle、クソだ。

# ビルドが遅い

今の環境だと、全ての AssetBundle を生成するのに**３時間**掛かる。
使ってるマシンはかなり高性能なマシンであるはずの Mac Pro である。

今のプロジェクトでは、前述したメモリの問題や、更新分のダウンロードが難しいので、１アセット（＋依存ファイル）ずつ AssetBundle を生成している。
そのため AssetBundle の数が 2500 個以上あるのだが、それでも３時間は掛かり過ぎだ。

これを解決するために、更新の無いファイルは何もしないような処理を自分で書かなければならなかった。
Unity は、もっと AssetBundle の生成処理を速くするか、無駄な AssetBundle の生成をしないといった処理を入れるべきだろう。
あるいは、小さな AssetBundle を大量に作らないといけないような状態になっているのを解決すべきだろう。

まあとにかく、クソだ。

# おわりに

ここまで、AssetBundle のクソな点をひたすら書いてきた。
最後に特大のクソを紹介しよう。
これだけクソな AssetBundle なのだが、**現状は使わざるを得ない** というのが最大級のクソである。

プレハブを問題なくシリアライズし、ロード時にこれだけ高速に組み立てられるのは、恐らく AssetBundle だけであるからだ。
一応 Asset Store にもプレハブをシリアライズするパッケージはあるが、内部構造が変わると使えなくなるだろうし、ロード時に高速に組み立てるのも無理だろう。

Unity はわざとプレハブをシリアライズできないようにしているのだと思う。
シリアライズ、デシリアライズが高速にできるなら、Unity ユーザは、Unity Pro を使ってまでして AssetBundle を使おうとはせず、Asset Store から適当なのを使うからだ。

実行時に自前でプレハブを組み立てる、あるいはアプリケーション本体の中にプレハブのデータだけ入れておいて、自前でリソースをセットするという方法もあるが、前者は組み立てに時間が掛かるだろうし、後者はプレハブの修正を AssetBundle のダウンロードで解決できない。

これだけクソであっても使わざるを得ない AssetBundle、最後までクソだった。
