<p>ありがとうございます！あちらはログインしないとコメントが書けなかったので助かります。<br>
（多分 syocy さんも見てくれてると思うので以下コメント）</p>

<p>私の記事は、「なぜ Haskell から C++ に置き換えたのか？」という疑問に答えるために深く掘り下げず書いたので、Yesod だけが問題で Haskell は問題ないという感じに読めたかもしれません。<br>
私はちゃんと、Haskell の型や、遅延評価や、文化などについて良くない感想を持っていて、Haskell そのものが真面目なアプリケーション開発には向いてないと思っています。<br>
（具体的に書くのは大変なので省略させて下さい…）</p>

<blockquote>
<p>"Haskell は真面目なアプリケーション開発には向いてない"について</p>
</blockquote>

<p>Haskellでアプリケーションを実際に作っていることと、アプリケーション開発に向いているかどうかというのは、全くとは言わないものの、ある程度別の問題だと考えています。<br>
大量のリソースを投入すれば、どんなに向いてない言語だろうと大体のものは作れるので、実際に作れたということが向いているかどうかと言われると、首を傾げるところです。</p>

<p>Haskellを学んだり、正しく書いたり、運用していくには、私の使ってきた他の言語と比べると、めちゃめちゃコストが掛かるというのが私の実際に学んで書いて運用してみた感想です。<br>
そのコストを支払い続けてでもその言語で開発・運用していくメリットがあるのか？と言われると、当時の私は「無い」と思いました。<br>
今は Stack によって開発環境を整えるのが楽になったみたいなので少しマシなのかもしれませんが、触ってないのでなんとも言えません。</p>

<blockquote>
<p>ドキュメントがない？</p>
</blockquote>

<p>まあ、悪いことは記憶に残りやすいから、ドキュメントが無かったことがよく記憶に残ってるだけ、という可能性もあります。<br>
ただ、自分が使おうとした <a href="http://hackage.haskell.org/package/shakespeare-2.0.13/docs/Text-Hamlet-RT.html" rel="nofollow noopener" target="_blank">Text.Hamlet.RT</a> はドキュメントが無くて頑張ってソースを読むしか無かったし、<a href="https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html" rel="nofollow noopener" target="_blank">Conduit</a> あたりも例が無さすぎてどう使えばいいか分からなかったりした記憶があります。<br>
これは私の能力の問題のような気もしますが、Haskell のライブラリは、大体が型クラスを使って抽象化されてるものばかりであるせいか理解するのが難しく、具体的なコードが無いとパズルみたいにいろいろ組み合わせてコンパイルが通るまで試す的な感じになって無限に時間を使ってしまうのです。</p>

<p>あと、これは Haskell のドキュメントそのものの問題だと思うのですが、instance や constructor に説明を書いてるドキュメントはほぼ無いんですよね。<br>
例えば <a href="https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#t:ConduitM" rel="nofollow noopener" target="_blank">Conduit</a> の説明、<code>Monad</code> とか <code>MonadThrow</code> とかをインスタンス化してますが、これが実際にどういう効果を起こすのかについて書いてない。<br>
まあ <code>Monad</code> ぐらいはここの外のドキュメントに例が載ってるので理解できるのですが、他のはどういう挙動をするのか分からないので困っていました。（困った場所が Conduit だったかどうかは記憶していないです。Yesod のどれかのモジュールだったかも）</p>

<blockquote>
<p>開発しているアプリケーションにストリーム処理ライブラリが必要と分かったなら、一度調査してどれかに決定すればいいだけのはず</p>
</blockquote>

<p>確か Yesod （かその依存ライブラリ）が使っているライブラリが、Yesod を更新する度にコロコロ変わっていて、それによってインターフェースが変わりまくっていました。<br>
だから調査をし直す必要があったと記憶しています。</p>

<p>仕方ないので Yesod のバージョンを固定しよう、と思っていたら、記事に書いている通りのことになりました。</p>

<blockquote>
<p>"Yesod は新しいライブラリを大量に使うのでそれに引っ張られた" という趣旨のことも書かれていますが、これは Yesod の問題であって Haskell の問題とは言えません。</p>
</blockquote>

<p>Haskell は、「コンパイルエラーになるから安心してインターフェースを変えられる」と考える文化があるように思います。<br>
なので、新しいものを使いまくるし、既存のメソッドはバージョンアップによって消すし、全く別のライブラリを利用したり、それによってインターフェースを変えたりする、というのが私のイメージです。</p>

<p>真面目なアプリケーションを書く時、（Yesodで無くとも）標準以外のライブラリを使っていくはずで、それらのライブラリを新しくする度にコンパイルが通らなくなるのは、依存するライブラリが多ければ多いほど辛くなるんじゃないかなと思います。</p>

<blockquote>
<p>互換性壊しすぎ?</p>
</blockquote>

<p>これは私の書き方が悪くて、互換性を壊しているのは Yesod を含む、Haskell のライブラリ達のことです。<br>
上記に書いているように、Haskell の文化の問題だと思います。</p>
