Elixir には Range 型があります。
これは `1..3` とか `Range.new(1, 3)` とか書くと生成できて、`Enumerable` プロトコルを実装してるので `for` で回せます。

```elixir
iex> for n <- 1..3 do
...>   n * 2
...> end
[2, 4, 6]
```

範囲を扱う場合、大体の言語で終端の値を含むか含まないかでいろいろあるのですが、Elixir の場合、`1..3` は `3` を含みます。

また、Elixir は `3..1` なんかすると 3 から始まり 1 までの範囲を表します。

```elixir
iex> Enum.to_list(3..1)
[3, 2, 1]
```

どちらも問題無さそうな機能に見えますが、自分はこの２つの仕様が合わさるのは良くないと考えています。
なぜなら **空の範囲が表現できなくなる** からです。
`1..1` は 1 だけの範囲だし、`1..0` は 1 と 0 の範囲です。空の範囲が表現できません。[^1]

[^1]: 当然空の範囲が欲しいという話は一度 [議論](https://github.com/elixir-lang/elixir/issues/1017) されているのだけど、結局入らないまま。

これが実際どういう時に問題になるかというと、例えばマクロで使うために `t1` から `tn` までの `n` 個の引数リストを作りたい場合、

```elixir
def make_args(n) do
  for v <- 1..n do
    {:"t#{v}", [], Elixir}
  end
end
```

とか書くわけですが、これだと `make_args(0)` と呼び出した時に意図した動作にはなりません。
本来は `[]` が返されて欲しいのですが、`1..0` が `1, 0` となってしまうため、`t1` と `t0` の引数リストが返されることになります。

なので以下のように書く必要があります。

```elixir
def make_args(0) do
  []
end

def make_args(n) do
  for v <- 1..n do
    {:"t#{v}", [], Elixir}
  end
end
```

あるいは [`:lists.seq/2`](http://erlang.org/doc/man/lists.html#seq-2) を使うという手もあります。

```elixir
def make_args(n) do
  for v <- :lists.seq(1, n) do
    {:"t#{v}", [], Elixir}
  end
end
```

`1..0` と違い、`:lists.seq(1, 0)` の場合は空のリストを返すため、これで正しく動作します。[^2]

[^2]: `:lists.seq/2` を見ると、なぜ `1..0` はマイナス方向に進む仕様にしてしまったのかという気持ちで一杯になる。

このように、n 回処理をする、という内容で n が 0 のケースがある場合には `:lists.seq/2` を使うのが無難そうです。
ただし n が膨大な数になる場合には `:lists.seq/2` を使うのは危険なので、その場合は分岐が必要になります。
この使い分けはかなり疲れそうなので、やっぱり空の範囲が欲しいですね。
